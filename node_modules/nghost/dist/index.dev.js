"use strict";

var app = require('express')();

var favicon = require('serve-favicon');

var fs = require('fs');

var path = require('path');

var url = require('url');

var session = require('express-session');

var stringReplaceStream = require('string-replace-stream');

var bodyParser = require('body-parser');

var options = {
  publicFolder: path.join(__dirname, 'public'),
  hostname: 'localhost',
  favicon: path.join(__dirname, 'favicon.ico'),
  port: 80,
  bodyParser: true,
  encode: 'utf-8',
  session: '',
  contents: [{
    key: /\.html$/,
    type: 'text',
    contentType: 'text/html'
  }, {
    key: /\.js$/,
    type: 'text',
    contentType: 'application/javascript'
  }, {
    key: /\.css$/,
    type: 'text',
    contentType: 'text/css'
  }, {
    key: /\.json$/,
    type: 'text',
    contentType: 'application/json'
  }, {
    key: /\.svg$/,
    type: 'binary',
    contentType: 'image/svg+xml'
  }, {
    key: /\.woff$/,
    type: 'binary',
    contentType: 'application/font-woff woff'
  }, {
    key: /\.woff2$/,
    type: 'binary',
    contentType: 'application/font-woff2'
  }, {
    key: /\.eot$/,
    type: 'binary',
    contentType: 'application/vnd.ms-fontobject eot'
  }, {
    key: /\.ttf$/,
    type: 'binary',
    contentType: 'application/x-font-ttf'
  }, {
    key: /\.mp4$/,
    type: 'binary',
    contentType: 'video/mp4'
  }, {
    key: /\.flv$/,
    type: 'binary',
    contentType: 'video/x-flv'
  }, {
    key: /\.map$/,
    type: 'binary',
    contentType: 'application/octet-stream'
  }, {
    key: /\.jpg$/,
    type: 'binary',
    contentType: 'image/jpg'
  }, {
    key: /\.png$/,
    type: 'binary',
    contentType: 'image/png'
  }, {
    key: /\.jpeg$/,
    type: 'binary',
    contentType: 'image/jpeg'
  }],
  gets: [],
  posts: [],
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "Origin, X-Requested-With, Content-Type, Accept"
};

var nghost = function nghost() {
  var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : options;
  options = addIfNotExist(options, option);

  if (!fs.existsSync(options.publicFolder)) {
    throw "Public folder not found.";
  }

  if (fs.existsSync(options.favicon)) app.use(favicon(options.favicon));

  if (option.session) {
    app.use(session({
      secret: option.session,
      resave: true,
      saveUninitialized: true
    }));
  }

  app.use(function (req, res, next) {
    res.header("Access-Control-Allow-Origin", options["Access-Control-Allow-Origin"]);
    res.header("Access-Control-Allow-Headers", options["Access-Control-Allow-Headers"]);
    next();
  });

  if (option.bodyParser) {
    app.use(bodyParser.json());
    app.use(bodyParser.urlencoded({
      extended: true
    }));
  }

  app.get(/.*/, function (req, res) {
    var exist = false;

    if (req.url.substring(0).search(/[^.]*$/) <= 0) {
      for (get in options.gets) {
        try {
          if (req.url.match(options.gets[get].key)) {
            exist = true;
            options.gets[get]["function"].call(options.gets[get], req, res);
            break;
          }
        } catch (Exept) {// if (Exept) console.log("Error :", Exept) 
        }
      }
    }

    if (!exist) {
      getGenericRequest(req, res);
    }
  });
  app.post(/.*/, function (req, res) {
    var exist = false;

    if (req.url.substring(0).search(/[^.]*$/) <= 0) {
      for (get in options.posts) {
        try {
          if (req.url.match(options.posts[get].key)) {
            exist = true;
            options.posts[get]["function"].call(options.posts[get], req, res);
            break;
          }
        } catch (Exept) {
          if (Exept) console.log("Error :", Exept);
        }
      }
    }

    if (!exist) {
      getGenericRequest(req, res);
    }
  });
  app.listen(options.port);
  return app;
};

function getGenericRequest(req, res) {
  var pathName = url.parse(req.url).pathname.split('/').filter(function (e) {
    return e.length > 0;
  });

  if (pathName.length == 0) {
    res.setHeader('Content-Type', 'text/html');
    res.write(fs.readFileSync(path.join(options.publicFolder, 'index.html'), 'utf-8'));
    res.end();
  } else checkReqAndSend(pathName.join('/'), res);
}

function checkReqAndSend(req, res) {
  var exist = false;

  for (ctn in options.contents) {
    if (req.match(options.contents[ctn].key)) {
      exist = true;

      if (options.contents[ctn].type == 'text') {
        responseText(res, req, options.contents[ctn].contentType);
      } else {
        responseBinary(res, req, options.contents[ctn].contentType);
      }

      break;
    }
  }

  if (!exist) {
    if (req.match(/^\/[a-zA-Z]{1}[a-zA-Z0-9]{2,8}$/)) {
      var file = path.join(options.publicFolder, req) + ".html";
      fs.access(file, function (err) {
        if (err) {
          response(res, "404", "<h1 style=\"color:green; font-size:5em; font-weight:100;\">\n                        Ok Successful route But We Don't find the file...\n                    </h1>");
        } else {
          responseText(res, "".concat(req, ".html"), "text/html");
        }
      });
    } else {
      response(res, "404", "<h1 style=\"color:red; font-size:5em; font-weight:100;\">Error Request</h1>");
    }
  }
}

function responseText(res, file, contentType) {
  response(res, file, contentType, options.encode);
}

function responseBinary(res, file, contentType) {
  response(res, file, contentType);
}

var response = function response(res, file, contentType, encode) {
  if (file != "404") {
    res.writeHead(200, {
      "Content-type": contentType
    });

    if (encode) {
      var stream = fs.createReadStream(path.join(options.publicFolder, file), encode).pipe(stringReplaceStream("localhost:" + options.port, options.hostname + ":" + options.port));
    } else {
      var stream = fs.createReadStream(path.join(options.publicFolder, file)).pipe(stringReplaceStream("localhost:" + options.port, options.hostname + ":" + options.port));
    }

    stream.pipe(res);
  } else {
    res.writeHead(404, {
      "Content-type": "text/html"
    });
    res.end("\n            ".concat(contentType, "\n        "));
  }
};

var addIfNotExist = function addIfNotExist(obj1, obj2) {
  //Fetch Contents
  if (obj2.contents) {
    var result;

    for (ctn in obj1.contents) {
      result = obj2.contents.filter(function (obj) {
        return String(obj.key) === String(obj1.contents[ctn].key);
      });

      if (result.length == 0) {
        obj2.contents.push(obj1.contents[ctn]);
      }
    }
  } //Fetch Gets


  if (obj2.gets) {
    var result;

    for (ctn in obj1.gets) {
      result = obj2.gets.filter(function (obj) {
        return String(obj.key) === String(obj1.gets[ctn].key);
      });

      if (result.length == 0) {
        obj2.gets.push(obj1.gets[ctn]);
      }
    }
  } //Fetch Posts


  if (obj2.posts) {
    var result;

    for (ctn in obj1.posts) {
      result = obj2.posts.filter(function (obj) {
        return String(obj.key) === String(obj1.posts[ctn].key);
      });

      if (result.length == 0) {
        obj2.posts.push(obj1.posts[ctn]);
      }
    }
  } //Fetch session keys


  if (obj2.sessionKey) {
    var result;

    for (ctn in obj1.sessionKey) {
      result = obj2.sessionKey.filter(function (obj) {
        return String(obj.key) === String(obj1.sessionKey[ctn].key);
      });

      if (result.length == 0) {
        obj2.sessionKey.push(obj1.sessionKey[ctn]);
      }
    }
  } //load all option element 


  for (element in obj1) {
    if (obj2[element]) {
      obj1[element] = obj2[element];
    }
  }

  return obj1;
};

module.exports = nghost;